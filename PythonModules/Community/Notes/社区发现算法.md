# 基于Modularity的社区发现

## 一、简介

### 1、社区

社区是一个子图，包含顶点和边，同一社区内结点与结点之间的连接很紧密，而社区与社区之间的连接比较稀疏。

### 2、louvain与Modularity

Louvain算法是一种基于图数据的社区发现算法，通过模块度（Modularity）来衡量一个社区的紧密程度。被认为是性能最好的社区发现算法之一。

## 二、Modularity

### 1、Modularity模块度

Modularity模块度定义：
![Q = \sum_c( \frac{E_c}{m}-(\frac{\sum tot}{2m})^2)](https://math.jianshu.com/math?formula=Q%20%3D%20%5Csum_c(%20%5Cfrac%7BE_c%7D%7Bm%7D-(%5Cfrac%7B%5Csum%20tot%7D%7B2m%7D)%5E2))

其中![m](https://math.jianshu.com/math?formula=m)表示图中边的数量，![c](https://math.jianshu.com/math?formula=c)表示社区，![E_c](https://math.jianshu.com/math?formula=E_c)表示社区![c](https://math.jianshu.com/math?formula=c)内边的数量，![\sum tot](https://math.jianshu.com/math?formula=%5Csum%20tot)表示社区c节点的度之和

**计算案例^[1]^**
例如将图划分为三个社区，计算该图的模块度

![](https://upload-images.jianshu.io/upload_images/5616135-ee3a009be46af741.png?imageMogr2/auto-orient/strip|imageView2/2/w/571/format/webp)

这个图包含23条边，包含3个社区
社区1内部边5条(![E_1=5](https://math.jianshu.com/math?formula=E_1%3D5))，结点度之和为![2+3+3+3=11](https://math.jianshu.com/math?formula=2%2B3%2B3%2B3%3D11)
(![\sum tot=11](https://math.jianshu.com/math?formula=%5Csum%20tot%3D11))。
社区2内部边7条(![E_2=7](https://math.jianshu.com/math?formula=E_2%3D7))，结点度之和为![3+4+4+4+2=17](https://math.jianshu.com/math?formula=3%2B4%2B4%2B4%2B2%3D17)
(![\sum tot=17](https://math.jianshu.com/math?formula=%5Csum%20tot%3D17))。
社区3内部边8条(![E_3=8](https://math.jianshu.com/math?formula=E_3%3D8))，结点度之和为![4+3+4+3+4=18](https://math.jianshu.com/math?formula=4%2B3%2B4%2B3%2B4%3D18)
(![\sum tot=18](https://math.jianshu.com/math?formula=%5Csum%20tot%3D18))。

因此该图的模块度为：
![Q=[\frac{5}{23}-(\frac{11}{46})^2] + [\frac{7}{23}-(\frac{17}{46})^2] + [\frac{8}{23}-(\frac{18}{46})^2]=0.523](https://math.jianshu.com/math?formula=Q%3D%5B%5Cfrac%7B5%7D%7B23%7D-(%5Cfrac%7B11%7D%7B46%7D)%5E2%5D%20%2B%20%5B%5Cfrac%7B7%7D%7B23%7D-(%5Cfrac%7B17%7D%7B46%7D)%5E2%5D%20%2B%20%5B%5Cfrac%7B8%7D%7B23%7D-(%5Cfrac%7B18%7D%7B46%7D)%5E2%5D%3D0.523)

### 2、模块度与社区紧密关系

模块度值越大，说明社区划分的越好，社区越紧密。

模块度用来衡量一个社区的紧密程度

**（1）计算左图模块度**
左图包含23条边，包含2个社区

> 社区1内部边13条(![E_1=13](https://math.jianshu.com/math?formula=E_1%3D13))，结点度之和为![2+3+3+3+3+4+4+4+2=28](https://math.jianshu.com/math?formula=2%2B3%2B3%2B3%2B3%2B4%2B4%2B4%2B2%3D28) (![\sum tot=28](https://math.jianshu.com/math?formula=%5Csum%20tot%3D28))。
> 社区2内部边8条(![E_1=8](https://math.jianshu.com/math?formula=E_1%3D8))，结点度之和为![4+3+3+4+4=18](https://math.jianshu.com/math?formula=4%2B3%2B3%2B4%2B4%3D18) (![\sum tot=18](https://math.jianshu.com/math?formula=%5Csum%20tot%3D18))。
> 左图的模块度为：
> ![Q=[\frac{13}{23}-(\frac{28}{46})^2] + [\frac{8}{23}-(\frac{18}{46})^2]=0.3894](https://math.jianshu.com/math?formula=Q%3D%5B%5Cfrac%7B13%7D%7B23%7D-(%5Cfrac%7B28%7D%7B46%7D)%5E2%5D%20%2B%20%5B%5Cfrac%7B8%7D%7B23%7D-(%5Cfrac%7B18%7D%7B46%7D)%5E2%5D%3D0.3894)

**（2）计算右图模块度**
右图包含23条边，包含2个社区

> 社区1内部边5条(![E_1=5](https://math.jianshu.com/math?formula=E_1%3D5))，结点度之和为![2+3+3+3=11](https://math.jianshu.com/math?formula=2%2B3%2B3%2B3%3D11) (![\sum tot=11](https://math.jianshu.com/math?formula=%5Csum%20tot%3D11))。
> 社区2内部边17条(![E_1=17](https://math.jianshu.com/math?formula=E_1%3D17))，结点度之和为![3+4+2+4+4+4+4+3+4+3 = 35](https://math.jianshu.com/math?formula=3%2B4%2B2%2B4%2B4%2B4%2B4%2B3%2B4%2B3%20%3D%2035) (![\sum tot=35](https://math.jianshu.com/math?formula=%5Csum%20tot%3D35))。
> 右图的模块度为：
> ![Q=[\frac{5}{23}-(\frac{11}{46})^2] + [\frac{17}{23}-(\frac{35}{46})^2]=0.3204](https://math.jianshu.com/math?formula=Q%3D%5B%5Cfrac%7B5%7D%7B23%7D-(%5Cfrac%7B11%7D%7B46%7D)%5E2%5D%20%2B%20%5B%5Cfrac%7B17%7D%7B23%7D-(%5Cfrac%7B35%7D%7B46%7D)%5E2%5D%3D0.3204)

可以发现该图划分为三个社区的模块度值最大，划分为三个社区会比划分为两个社区更好。

## 三、louvain算法

Louvain算法是一种基于图数据的社区发现算法，通过模块度（Modularity）来衡量一个社区的紧密程度。

louvain如何使用Modularity来实现社区的发现？

### 1、louvain算法步骤

louvain算法步骤

> （1）初始化，将每个节点看作一个独立社区
> （2）尝试把节点i分配到相邻节点所在社区，计算分配前与分配后的模块度变化![\Delta Q](https://math.jianshu.com/math?formula=%5CDelta%20Q)，并记录![\Delta Q](https://math.jianshu.com/math?formula=%5CDelta%20Q)最大的社区，如果![Max \Delta Q > 0](https://math.jianshu.com/math?formula=Max%20%5CDelta%20Q%20%3E%200)，则将该节点分配到该社区。
> （3）重复操作步骤（2）直到所有节点的所属社区不再变化

探索一下该步骤：
 **结点0** ：分配到相邻结点1，2，3所在社区
分配前模块度：-0.0043；分配到{1}模块度：0.0265，分配到{2}模块度：0.0265，分配到{3}模块度：0.0317；根据最大模块度差异把结点0和3组合为一个社区。

 **结点1** ：分配到相邻结点0，2，3所在社区{0，3}，{2}
分配前模块度：-0.0043；分配到{0，3}模块度：0.1002，{2}模块度：0.0265；
根据最大模块度差异把结点1和2组合为一个社区，此时{1,2},{0,3}

 **结点2** ：分配到相邻结点0，1，4所在社区{0，3}，{1}，{4}
分配前模块度：-0.0043；分配到{0，3}模块度：0.0567，分配到{1}模块度：0.0265，分配到{4}模块度：0.0265。
根据最大模块度差异把结点2和3组合为一个社区，此时{0,2,3},{1},{4}
发现结点2的所属社区发生了变化

 **结点1** ：分配到相邻结点0,2,3所在社区{0,2,3}
分配前模块度：-0.0043；分配到{0,2,3}模块度：0.1167，比原社区{1}的模块度大，形成新的社区{0,1,2,3}

···

### 2、python-louvain

python-louvain提供community.best_partition函数，该函数通过计算最大模块度实现社区发现，是louvain算法的封装。

### 3、案例计算

（1）图关系构建

（2）社区发现

（3）验证上述左图、右图的计算结果

## 参考资料

[1] 社区检测：[https://zhuanlan.zhihu.com/p/41105026](https://links.jianshu.com/go?to=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F41105026)
[https://www.jianshu.com/p/4ebe42dfa8ec](https://www.jianshu.com/p/4ebe42dfa8ec)
[2] python-louvain函数文档：[https://python-louvain.readthedocs.io/_/downloads/en/latest/pdf/](https://links.jianshu.com/go?to=https%3A%2F%2Fpython-louvain.readthedocs.io%2F_%2Fdownloads%2Fen%2Flatest%2Fpdf%2F)
[3] 06年《Modularity and Community structure in networks 》一文：[https://wenku.baidu.com/view/15394e520912a216147929cc.html](https://links.jianshu.com/go?to=https%3A%2F%2Fwenku.baidu.com%2Fview%2F15394e520912a216147929cc.html)
